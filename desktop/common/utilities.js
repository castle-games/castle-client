import platform from 'platform';
import url from 'url';
import * as Strings from '~/common/strings';

const pathposix = require('path-posix');
const pathwin32 = require('path-win32');

const LUMINOSITY_THEME_BREAKPOINT = 0.62;

export const shadeHex = (color, percent) => {
  const f = parseInt(color.slice(1), 16),
    t = percent < 0 ? 0 : 255,
    p = percent < 0 ? percent * -1 : percent,
    R = f >> 16,
    G = (f >> 8) & 0x00ff,
    B = f & 0x0000ff;
  return (
    '#' +
    (
      0x1000000 +
      (Math.round((t - R) * p) + R) * 0x10000 +
      (Math.round((t - G) * p) + G) * 0x100 +
      (Math.round((t - B) * p) + B)
    )
      .toString(16)
      .slice(1)
  );
};

export const getLuminosityOfHex = (hex) => {
  const c = hex.substring(1); // strip #
  const rgb = parseInt(c, 16); // convert - rrggbb to decimal
  const r = (rgb >> 16) & 0xff; // extract - red
  const g = (rgb >> 8) & 0xff; // extract - green
  const b = (rgb >> 0) & 0xff; // extract - blue
  const luminosity = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709

  // NOTE(jim): Match IMGIX conversion
  return (luminosity / 2) * 0.01;
};

export const adjustTextColor = (hex) => {
  if (Strings.isEmpty(hex) || hex.length < 7) {
    hex = '#FFFFFF';
  }

  const luminosity = hex ? getLuminosityOfHex(hex) : LUMINOSITY_THEME_BREAKPOINT;
  return luminosity > LUMINOSITY_THEME_BREAKPOINT
    ? 'rgba(0, 0, 0, 0.8)'
    : 'rgba(255, 255, 255, 0.8)';
};

export const shuffle = (array) => {
  let counter = array.length;

  while (counter > 0) {
    let index = Math.floor(Math.random() * counter);
    counter--;
    let temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }

  return array;
};

export const colorLuminance = (hex, lum) => {
  // Validate hex string
  hex = String(hex).replace(/[^0-9a-f]/gi, '');
  if (hex.length < 6) {
    hex = hex.replace(/(.)/g, '$1$1');
  }
  lum = lum || 0;
  // Convert to decimal and change luminosity
  var rgb = '#',
    c;
  for (var i = 0; i < 3; ++i) {
    c = parseInt(hex.substr(i * 2, 2), 16);
    c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
    rgb += ('00' + c).substr(c.length);
  }
  return rgb;
};

export const increaseBrightness = (hex, percent) => {
  // strip the leading # if it's there
  hex = hex.replace(/^\s*#|\s*$/g, '');

  // convert 3 char codes --> 6, e.g. `E0F` --> `EE00FF`
  if (hex.length == 3) {
    hex = hex.replace(/(.)/g, '$1$1');
  }

  var r = parseInt(hex.substr(0, 2), 16),
    g = parseInt(hex.substr(2, 2), 16),
    b = parseInt(hex.substr(4, 2), 16);

  return (
    '#' +
    (0 | ((1 << 8) + r + ((256 - r) * percent) / 100)).toString(16).substr(1) +
    (0 | ((1 << 8) + g + ((256 - g) * percent) / 100)).toString(16).substr(1) +
    (0 | ((1 << 8) + b + ((256 - b) * percent) / 100)).toString(16).substr(1)
  );
};

export const adjustTextColorWithEmphasis = (hex, shouldBrighten) => {
  if (Strings.isEmpty(hex) || hex.length < 7) {
    hex = '#FFFFFF';
  }

  const luminosity = hex ? getLuminosityOfHex(hex) : LUMINOSITY_THEME_BREAKPOINT;
  if (shouldBrighten) {
    return luminosity > LUMINOSITY_THEME_BREAKPOINT
      ? 'rgba(50, 50, 50, 0.8)'
      : 'rgba(255, 255, 255, 0.9)';
  } else {
    return luminosity > LUMINOSITY_THEME_BREAKPOINT
      ? 'rgba(0, 0, 0, 0.8)'
      : 'rgba(255, 255, 255, 0.8)';
  }
};

export const getColorTypeFromHex = (hex) => {
  const luminosity = hex ? getLuminosityOfHex(hex) : LUMINOSITY_THEME_BREAKPOINT;
  return luminosity > LUMINOSITY_THEME_BREAKPOINT ? 'DARK' : 'LIGHT';
};

export const getRandomInt = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

export function isWindows() {
  const os = platform.os.toString();
  return os.toLowerCase().includes('windows');
}

export function path() {
  // cannot use npm 'path' module because it uses the 'process' module
  // to determine the current OS, which does not give the correct value on WSL.
  if (isWindows()) {
    return pathwin32;
  } else {
    return pathposix;
  }
}

function _splitRemoveEmpty(str, sep) {
  let components = str.split(sep);
  while (components.length && components[0].length == 0) {
    components.splice(0, 1);
  }
  return components;
}

// fix a broken file path generated by calling url.resolve() or url.format() on windows
export function fixWindowsFilePath(path) {
  if (path.startsWith('file://')) {
    // broken paths look something like file://c/Users/...
    let filePath = path.substring(7);
    let pathComponents = _splitRemoveEmpty(filePath, '/');
    if (!(pathComponents.length > 1)) {
      pathComponents = _splitRemoveEmpty(filePath, '\\');
    }
    if (pathComponents.length > 1) {
      let mount = pathComponents[0].toString().toUpperCase();
      if (mount[mount.length - 1] !== ':') {
        mount = `${mount}:`;
      }
      pathComponents[0] = mount;
      filePath = pathComponents.join('\\');
    }
    return `file://${filePath}`;
  }
  return path;
}

export function getScreenSettings(game) {
  const { dimensions, scaling, upscaling, downscaling } = game.metadata || {};
  const screenSettings = {
    width: 800,
    height: 450,
    upscaling: 'on',
    downscaling: 'on',
  };
  if (dimensions) {
    if (dimensions === 'full') {
      screenSettings.width = 0;
      screenSettings.height = 0;
    } else {
      const [widthStr, heightStr] = dimensions.split('x');
      screenSettings.width = parseInt(widthStr) || 800;
      screenSettings.height = parseInt(heightStr) || 450;
    }
  }
  if (scaling) {
    screenSettings.upscaling = scaling;
    screenSettings.downscaling = scaling;
  }
  if (upscaling) {
    screenSettings.upscaling = upscaling;
  }
  if (downscaling) {
    screenSettings.downscaling = downscaling;
  }
  return screenSettings;
}

export function getLuaEntryPoint(game) {
  if (game.entryPoint) {
    // if the server knows about this game, just use the value given by the server
    return game.entryPoint;
  }

  let urlToResolve;
  if (game.hostedUrl) {
    // this field was possibly populated by auto-upload code in `publishProjectAsync`.
    // if it exists, we prefer to load the code from the hosted url rather than
    // the local url.
    urlToResolve = game.hostedUrl;
  } else {
    urlToResolve = game.url;
  }

  if (!urlToResolve) {
    throw new Error(`Can't resolve lua entry point against this game url: ${urlToResolve}`);
  }
  let entryPoint;
  if (game.metadata && game.metadata.main) {
    entryPoint = url.resolve(urlToResolve, game.metadata.main);
    entryPoint = decodeURIComponent(entryPoint);
  } else {
    entryPoint = urlToResolve;
  }
  if (isWindows() && entryPoint) {
    entryPoint = fixWindowsFilePath(entryPoint);
  }
  return entryPoint;
}

export function getSessionLink(game, sessionId) {
  // e.g. https://castle.games/+someid/@author/title#sessionid
  return game && sessionId ? `${game.hostedUrl || game.url}#${sessionId}` : null;
}

export function getShortSessionLink(game, sessionId) {
  // e.g. @author/title#sessionid
  let sessionLink = getSessionLink(game, sessionId);
  if (sessionLink) {
    let matches = sessionLink.match(/^.+castle\.games.+\/(\@.+\/.+$)/);
    if (matches && matches.length >= 2) {
      return matches[1];
    }
  }
  return null;
}

export function isMultiplayer(game) {
  return game.metadata && !!game.metadata.multiplayer;
}
