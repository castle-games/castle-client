import metadatalib from 'castle-metadata';
import platform from 'platform';
import url from 'url';

import * as Actions from '~/common/actions';
import * as NativeUtil from '~/native/nativeutil';
import * as Strings from '~/common/strings';
import * as Urls from '~/common/urls';

function _isWindows() {
  const os = platform.os.toString();
  return (os.toLowerCase().includes('windows'));
}

// fix a broken file path generated by calling url.resolve() on windows
function _fixWindowsFilePath(path) {
  if (path.startsWith('file://')) {
    // broken paths look something like file://c/Users/...
    let filePath = path.substring(7);
    let pathComponents = filePath.split('/');
    while (pathComponents.length && pathComponents[0].length == 0) {
      pathComponents.splice(0, 1);
    }
    if (pathComponents.length > 1) {
      let mount = pathComponents[0].toString().toUpperCase();
      if (mount[mount.length - 1] !== ':') {
        mount = `${mount}:`;
      }
      pathComponents[0] = mount;
      filePath = pathComponents.join('\\');
    }
    return `file://${filePath}`;
  }
  return path;
}

function _validateMetadata(metadata, isRegistered) {
  if (!metadata) {
    throw new Error(`Metadata is invalid: ${metadata}`);
  }
  let validatedMetadata = { ...metadata };
  const registeredFields = [ 'gameId', 'user', 'slug' ];
  if (isRegistered) {
    registeredFields.forEach(field => {
      if (!validatedMetadata.hasOwnProperty(field)) {
        throw new Error(`Registered game is missing field: ${field}`);
      }
    });
  } else {
    // unregistered games can't have any of these
    registeredFields.forEach(field => {
      if (validatedMetadata.hasOwnProperty(field)) {
        delete validatedMetadata[field];
      }
    });
  }
  return validatedMetadata;
};

async function _resolveMetadataAtUrlAsync(metadataUrl) {
  try {
    let {
      metadata,
      info,
      errors,
      warnings
    } = await metadatalib.fetchMetadataForUrlAsync(metadataUrl, {
      readFileUrlAsyncFunction: NativeUtil.readFileUrl,
    });
    if (errors && errors.length) {
      throw new Error(`Error fetching metadata: ${errors.join(',')}`);
    }
    metadata = _validateMetadata(metadata, false);
    return { metadata, info };
  } catch (e) {
    throw new Error(`Couldn't resolve metadata at .castle url: ${e.message}`);
  }
  return null;
}

async function _readGameFromMetadataUrlAsync(url) {
  let game = { url };
  const { metadata, info } = await _resolveMetadataAtUrlAsync(url);
  if (info && info.main) {
    game.entryPoint = info.main;
  }
  if (metadata) {
    game.metadata = metadata;
    if (metadata.name) game.name = metadata.name;
    if (metadata.description) game.description = metadata.description;
    if (metadata.username) game.username = metadata.username;
  }
  return game;
}

async function resolveGameAtUrlAsync(gameUrl) {
  let game;

  // always try to resolve from the server first
  try {
    game = await Actions.getGameByUrl(gameUrl);
    game.metadata = _validateMetadata(game.metadata, !Strings.isEmpty(game.gameId));
    if (game.metadata.main) {
      game.entryPoint = url.resolve(gameUrl, game.metadata.main);
    }
  } catch (e) {
    game = null;
  }

  // if the server failed, try to read the .castle file directly
  if (!game && Urls.isMetadataFileUrl(gameUrl)) {
    try {
      game = await _readGameFromMetadataUrlAsync(gameUrl);
    } catch (e) {
      game = null;
    }
  }

  // if nothing worked, assume this is a direct url to some code with no metadata
  if (!game) {
    game = {
      url: gameUrl,
      entryPoint: gameUrl,
    }
  };

  if (_isWindows() && game.entryPoint) {
    game.entryPoint = _fixWindowsFilePath(game.entryPoint);
  }

  return game;
}

export {
  resolveGameAtUrlAsync,
};
