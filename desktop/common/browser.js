import metadatalib from 'castle-metadata';
import platform from 'platform';

import * as Actions from '~/common/actions';
import * as NativeUtil from '~/native/nativeutil';
import * as Urls from '~/common/urls';

function _isWindows() {
  const os = platform.os.toString();
  return (os.toLowerCase().includes('windows'));
}

// fix a broken file path generated by calling url.resolve() on windows
function _fixWindowsFilePath(path) {
  if (path.startsWith('file://')) {
    // broken paths look something like file://c/Users/...
    let filePath = path.substring(7);
    let pathComponents = filePath.split('/');
    while (pathComponents.length && pathComponents[0].length == 0) {
      pathComponents.splice(0, 1);
    }
    if (pathComponents.length > 1) {
      let mount = pathComponents[0].toString().toUpperCase();
      if (mount[mount.length - 1] !== ':') {
        mount = `${mount}:`;
      }
      pathComponents[0] = mount;
      filePath = pathComponents.join('\\');
    }
    return `file://${filePath}`;
  }
  return path;
}

function _validateMetadata(metadata, isRegistered) {
  if (!metadata) {
    throw new Error(`Metadata is invalid: ${metadata}`);
  }
  let validatedMetadata = { ...metadata };
  if (isRegistered) {
    // TODO: enforce mediaId
  } else {
    // unregistered media can't have any of these
    const fieldsToRemove = [ 'mediaId', 'user', 'slug' ];
    fieldsToRemove.forEach(field => {
      if (validatedMetadata.hasOwnProperty(field)) {
        delete validatedMetadata[field];
      }
    });
  }
  return validatedMetadata;
};

async function _resolveMetadataAtUrlAsync(metadataUrl, isRegisteredMedia) {
  try {
    let {
      metadata,
      info,
      errors,
      warnings
    } = await metadatalib.fetchMetadataForUrlAsync(metadataUrl, {
      readFileUrlAsyncFunction: NativeUtil.readFileUrl,
    });
    if (errors && errors.length) {
      throw new Error(`Error fetching metadata: ${errors.join(',')}`);
    }
    if (info && info.isPublicUrl) {
      // If its a public URL, index it on the server
      // Don't `await` since we don't want to block
      // loading the media
      Actions.indexPublicUrlAsync(metadataUrl);
    }
    metadata = _validateMetadata(metadata, isRegisteredMedia);
    return { metadata, info };
  } catch (e) {
    throw new Error(`Couldn't resolve metadata at .castle url: ${e.message}`);
  }
  return null;
}

async function resolveMediaAtUrlAsync(mediaUrl) {
  let metadataUrl = mediaUrl;
  let entryPoint = mediaUrl;
  let metadataFetched = {};
  let isRegisteredMedia = false;

  // TODO: ben: move to getGameByURL
  if (Urls.isCastleHostedUrl(mediaUrl)) {
    try {
      // look up underlying .castle url to retrieve metadata
      let { username, slug } = Urls.parseIdFromCastleHostedUrl(mediaUrl);
      metadataUrl = await Actions.getPrimaryUrlForRegisteredMediaByIdAsync(username, slug);
      if (metadataUrl) {
        isRegisteredMedia = true;
      }
    } catch (e) {
      // this didn't work, try to get metadata from the original url
      metadataUrl = mediaUrl;
    }
  }

  if (Urls.isMetadataFileUrl(metadataUrl)) {
    const { metadata, info } = await _resolveMetadataAtUrlAsync(metadataUrl);
    if (info && info.main) {
      entryPoint = info.main;
    }
    metadataFetched = metadata;
  }

  if (_isWindows() && entryPoint) {
    entryPoint = _fixWindowsFilePath(entryPoint);
  }

  return {
    mediaUrl,
    entryPoint,
    ...metadataFetched,
  };
};

export {
  resolveMediaAtUrlAsync,
};
