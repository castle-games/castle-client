--- @module display

--- Render using a texture.
-- Also see the <a href="https://poke1024.github.io/tove2d/features/">TÖVE Feature Matrix</a>.
-- @usage
-- graphics:setDisplay("texture")
-- @table texture
-- @tparam string mode `"texture"`
-- @see Graphics:draw
-- @see Graphics:setDisplay
-- @see Graphics:setResolution

--- Render using a mesh.
-- If no tesselator is specified, a default tesselator will be chosen based on the configured
-- usage of the @{Graphics}.
-- Also see the <a href="https://poke1024.github.io/tove2d/features/">TÖVE Feature Matrix</a>.
-- @usage
-- graphics:setDisplay("mesh") -- default configuration (based on configured usage)
--
-- graphics:setDisplay("mesh", 1024) -- make it look good at a size of 1024 pixels
-- -- will choose tesselation settings based on configured usage
--
-- graphics:setDisplay("mesh", "rigid", 4) -- 4 subdivision levels (=2^4 points per curve)
-- graphics:setDisplay("mesh", tove.newRigidTesselator(4)) -- same as above
--
-- graphics:setDisplay("mesh", "adaptive", 1024) -- target a size of 1024
-- graphics:setDisplay("mesh", tove.newAdaptiveTesselator(1024)) -- same as above
-- @table mesh
-- @tparam string mode `"mesh"`
-- @tparam[opt] Tesselator|string|number tesselator tesselator to use or name of tesselator type or target size
-- @tparam[optchain] ... args configuration of tesselator
-- @see Graphics:draw
-- @see Graphics:setDisplay
-- @see Graphics:setResolution
-- @see Graphics:setUsage

--- Render exclusively on the GPU.
-- `"gpux"` means "gpu exclusive": this mode will implicitly render all curve geometry on the fly
-- on the GPU. This has considerable resolution until it breaks down, however it can also be
-- quite expensive in terms of performance (note also that it needs one GL context change per path).
-- It is quite experimental as well: TÖVE is - to the best of my knowledge - the first library
-- capable of rendering complex cubic bezier shapes inside GLSL shaders without doing some kind
-- of tesselation. The only other existing implementation with this kind of approach seems to be
-- <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_path_rendering.txt">NVidia™'s GPU Accelerated Path Rendering</a>.
-- Also see the <a href="https://poke1024.github.io/tove2d/features/">TÖVE Feature Matrix</a>.
-- Please note that on some systems (e.g. macOS) computing `gpux` shaders can take a very long
-- time (e.g. 20s for one single SVG).
-- @usage
-- graphics:setDisplay("gpux")
-- graphics:setDisplay("gpux", "vertex")  -- use vertex shader for line drawing
-- @table gpux
-- @tparam string mode `"gpux"`
-- @tparam[opt="fragment"] string lineRenderer line shader (`"fragment"` or `"vertex"`). use `"fragment"`
-- for lines that need to have round edges, use `"vertex"` for lines that need to have miters.
-- You can use demos/editor to get an idea of the differences of this setting for various geometries.
-- @tparam[optchain=1] number lineQuality line quality (between 0 and 1). Higher numbers are
-- slower (`"fragment"` lines) or generate more geometry (`"vertex"` lines).
-- @see Graphics:draw
-- @see Graphics:setDisplay

--- @type Tesselator

-- Tesselators may be created using `tove.newAdaptiveTesselator` and `tove.newRigidTesselator`.

--- Create an adaptive tesselator.
-- Use this for high quality static graphics content that does not animate its shape in realtime.
-- Adaptive Tesselators create meshes that give more subdivision (i.e. points and triangles) to areas where 
-- higher detail is needed (curvy areas), whereas other areas (straight lines) might get less subdivision
-- and need less points. The number of vertices produced by
-- Adaptive Tesselators depends on the specific geometry. They are not suited for shape animation, as each shape
-- change would result in a different number of vertices and triangles.
-- @function tove.newAdaptiveTesselator
-- @tparam number resolution resolution at which the mesh should look good
-- @tparam[opt] int recursionLimit maximum number of recursions during subdivision

--- Create a rigid tesselator.
-- Use this to obtain low or medium quality meshes that can distort and animate their shapes in realtime.
-- Rigid tesselators subdivide geometry using fixed steps and thus produce a fixed number of vertices. As an
-- effect, all areasy of the geometry receive the same level of detail and subdivision. They are suited for
-- shape animation, as the vertex count stays constant and underlying meshes can be updated efficiently.
-- @function tove.newRigidTesselator
-- @tparam int subdivisions number of recursive subdivisions; 3 means 2^3=8 points for each bezier curve,
-- 4 indicates 2^4=16 points, and so on.

